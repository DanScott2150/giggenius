from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import xml.etree.ElementTree as ET
import openai
from dotenv import dotenv_values
import re

from langchain.chat_models import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.prompts.chat import SystemMessagePromptTemplate, HumanMessagePromptTemplate
from langchain.output_parsers import PydanticOutputParser
from langchain.pydantic_v1 import BaseModel, Field

config = dotenv_values('.env')
openai.api_key = config["OPENAI_API_KEY"]

app = Flask(__name__)
app.config.from_object(__name__)

CORS(app, resources={r'/*': {'origins': '*'}})

@app.route("/generate-analysis", methods=['POST'])
def generate_analysis():
	"""
		Takes description for a given job and makes API call to OpenAI to analyze how it aligns to user's profile

		Parameters:
		- request object will contain key:value pairs -- aboutMeText, jobText, guid

		Returns:
		- A JSON response containing the analysis generated by the model.

		Note:
		- OpenAI prompts for System and User messages are hardcoded here. Will eventually move elsewhere to be more dynamic.
		- @TODO look into chaining responses, rather than adding display:none to the first part of the response.
	"""

	args = request.json
	model = "gpt-3.5-turbo"
	llm = ChatOpenAI(temperature=0, model=model)

	# Schema for how we want the AI model to return data to us
	class Analysis(BaseModel):
		my_experience: str = Field(description="The MY_EXPERIENCE analysis provided by AI model")
		job_summary: str = Field(description="The JOB_SUMMARY analysis provided by AI model")
		match_summary: str = Field(description="The MATCH_SUMMARY analysis provided by AI model")
		match_decision: str = Field(description="The MATCH_DECISION determined by AI model")

	parser = PydanticOutputParser(pydantic_object=Analysis)
	format_instructions = parser.get_format_instructions()

	user_prompt = f'''
		MY EXPERIENCE: ### {args["aboutMeText"]} ###
		JOB DESCRIPTION: ### {args["jobText"]} ###
		JOB ID: ### {args["guid"]} ###
		'''

	system_prompt = """
		You are an expert HR professional, highly skilled in evaluating whether or not an applicant would be a good fit for a job.
		Your job is to take inputs provided by the user, and decide whether or not the job is a "match" for the applicant.

		You will be provided with two inputs: MY_EXPERIENCE, and JOB_DESCRIPTION.

		When given a task, you will think it through step-by-step:

		First: Create a *bullet point summary* of MY_EXPERIENCE. Bullet points should only reference things that are explicitly declared within MY_EXPERIENCE. This *bullet point summary* will be referred to as the "APPLICANT_SUMMARY" in the following steps.
		Second: Create a *bullet point summary* of the requirements being asked for in JOB_DESCRIPTION. Bullet points should only reference things that are explicitly declared within JOB_DESCRIPTION and should be ranked in order of importance. This *bullet point summary* will be referred to as the "JOB_SUMMARY" in the following steps.
		Third: Compare the APPLICANT_SUMMARY and JOB_SUMMARY and determine whether or not the user is a strong candidate for this position, and explain your reasoning in 1 paragraph. This will be referred to as the "MATCH_SUMMARY" in the following steps.
		Fourth: Based on the MATCH_SUMMARY you generated, decide on a classification: "Strong Candidate", "Weak Candidate", or "Not a Candidate". This will be referred to as the MATCH_DECISION.

		{format_instructions}
		"""

	messages = [
		SystemMessagePromptTemplate.from_template(system_prompt),
		HumanMessagePromptTemplate.from_template(user_prompt)
	]

	template = ChatPromptTemplate(
		messages=messages,
	)

	try:
		input = template.format_messages(user_prompt=user_prompt, format_instructions=format_instructions)
		output = llm(input)
		content = parser.parse(output.content)
		return jsonify(content.dict())

	except Exception as error:
		print('Error generating analysis:', error)
		return "Error generating output."


@app.route("/fetch-upwork-jobs-rss")
def fetch_upwork_jobs_rss():
	"""
		Fetches list of jobs from Upwork RSS feed - specific to an individual account's saved search options. DOES NOT scrape the Upwork website.

		Returns:
			list: A list of job information dictionaries.

		Raises:
			Exception: If there is an error fetching the Upwork RSS feed.

		Notes:
		- @TODO URL currently hardcoded. Move it elsewhere to make the config parameters in the URL more dynamic & changeable
		- @TODO parse more data points from the Upwork RSS feed
	"""

	## Upwork RSS Feed URL
	# This URL should populate to your saved search options (keyword, budget, etc)
	# target_url = 'https://www.upwork.com/ab/feed/jobs/rss?api_params=1&contractor_tier=1,2,3&hourly_rate=50-&job_type=hourly,fixed&orgUid=872559107033931777&paging=0;3&q=wordpress&securityToken=de56b8790f403c07196293547743d7d0aa964c95b1ad8dbba549fb823dfdbf2ef9ca3f6cb441593ab02952d74ecd8bc19ccf63dd5173aea09e263182b98f2c55&sort=recency&userUid=742862918896668672&user_location_match=1'
	# target_url = 'https://www.upwork.com/ab/feed/jobs/rss?q=wordpress&sort=recency&user_location_match=1&paging=0%3B10&api_params=1&userUid=742862918896668672'
	target_url = 'https://www.upwork.com/ab/feed/jobs/rss?q=wordpress&sort=recency&user_location_match=1&paging=0;10&api_params=1&hourly_rate=50-&job_type=hourly,fixed'

	jobs = []

	try:
		response = requests.get(target_url)

		# RSS Data returned in XML format. Need to parse
		data = ET.fromstring(response.text)
		items = data.findall('.//item')

		'''
			Example structure:
			<item>
				<title>
				<link>
				<description> // Contains <b>Skills</b>, <b>Budget</b>, <b>Hourly Range</b> which we can further parse out
				<content:encoded> //same as description
				<pubDate>
				<guid>
			</item>
		'''

		for job in items:

			titleItem = job.find('title')

        	# Remove excessive upwork branding from title
			if titleItem is not None and titleItem.text.endswith(" - Upwork"):
				title = titleItem.text.rsplit(" - Upwork", 1)[0]
			else:
				title = titleItem.text

			description = job.find('description').text

			# Budget is nested within description as text content. Need regex pattern match.
			# Upwork jobs can either be fixed-price or hourly-range:
			# 	If fixed-price, value labeled as "Budget" within description content.
			# 	If hourly-range, value labeled as "Hourly Range" within description content.
			# Use regex to check one, then the other
			budgetMatchFixed = re.search(r'(<b>Budget</b>: \$(\d+))', description)
			budgetMatchHourly = re.search(r'(<b>Hourly Range</b>: (\$\d+\.\d+-\$\d+\.\d+))', description)

			budget = "N/A"

			if budgetMatchFixed:
				budget = "$" +budgetMatchFixed.group(2)
				description = re.sub(re.escape(budgetMatchFixed.group(1)), '', description) # Remove from description content to avoid redundancy
			elif budgetMatchHourly:
				budget = budgetMatchHourly.group(2)
				description = re.sub(re.escape(budgetMatchHourly.group(1)), '', description) # Remove from description content to avoid redundancy

			# Remove "Posted On" line from description content to prevent redundancy, since we extract it elsewhere
			postedOnMatch = re.search(r'(<b>Posted On</b>: .+? UTC<br />)', description)
			if postedOnMatch:
				description = re.sub(re.escape(postedOnMatch.group(1)), '', description)

			job_info = {
				'guid': job.find('guid').text,
				'aiAnalysis': {
					'decision': '',
					'summary': ''
				},
				'budget': budget,
				'description': description,
				'feedback': {},
				'title': title,
				'url': job.find('link').text,
				'pubDate': job.find('pubDate').text
			}
			# print(job_info)
			jobs.append(job_info)

	except Exception as error:
		print('Error fetching upwork RSS:', error)

	return jsonify(jobs)


@app.route("/generate-proposal", methods=["POST"])
def generate_proposal():
	"""
		Similar to generate_analysis(), however generate a proposal/cover letter tailored to the job & user, rather than analyzing the match quality

		Parameters:
		- request object will contain key:value pairs -- aboutMeText, jobText

		Returns:
		- A JSON response containing the proposal generated by the model.

		Note:
		- OpenAI prompts for System and User messages are hardcoded here. Will eventually move elsewhere to be more dynamic.
	"""

	args = request.json
	model = "gpt-3.5-turbo"
	llm = ChatOpenAI(temperature=0, model=model)

	user_prompt = f'''
		MY EXPERIENCE: ### {args["aboutMeText"]} ###
		JOB DESCRIPTION: ### {args["jobText"]} ###
	'''

	template = ChatPromptTemplate.from_messages([
		(
			"system",
			'''
				CONTEXT: You're an expert at writing cover letters, geared towards applicants who are applying for web-development
				freelance jobs on Upwork. Your goal is to take inputs provided by the user, and output a well-written cover letter.

				The user will provide you with two inputs: MY_EXPERIENCE, and JOB_DESCRIPTION.

				Based on these two inputs, you should construct a well-written cover letter that will help the user apply for the job and stand out from the competition.
				This cover letter should be specifically tailored to the JOB_DESCRIPTION and MY_EXPERIENCE, and should only make reference to things that are explicitly mentioned within MY_EXPERIENCE and JOB_DESCRIPTION.

				The output cover letter should be between 2 and 4 paragraphs.
				It should be written in a friendly and conversational manner, rather than a formal or robotic tone.
				The first paragraph should start with a brief introduction.
				The middle paragraphs should emphasize the overlap between MY_EXPERIENCE and the JOB_DESCRIPTION.
				Only address aspects of JOB_DESCRIPTION that are a match with MY_EXPERIENCE.
				The closing paragraph should invite the hiring manager to view the user's upwork profile, and ask the hiring manager if they'd like to setup a call to "chat more" sometime.
			'''
		),
		(
			"human", user_prompt
		)
	])

	try:
		answer = llm(template.format_messages(user_prompt=user_prompt))
		analysis = answer.content
		return jsonify(analysis)
	except Exception as error:
		print('Error generating analysis:', error)
		return "Error generating output."


if __name__ == '__main__':
	app.run()
