from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import xml.etree.ElementTree as ET
import openai
from dotenv import dotenv_values
import re

from langchain.chat_models import ChatOpenAI
from langchain.prompts.chat import SystemMessagePromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate
from langchain.schema import StrOutputParser
from langchain.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field

config = dotenv_values('.env')
openai.api_key = config["OPENAI_API_KEY"]

app = Flask(__name__)
app.config.from_object(__name__)

CORS(app, resources={r'/*': {'origins': '*'}})

@app.route("/generate-analysis", methods=['POST'])
def generate_analysis():
	"""
		Takes description for a given job and makes API call to OpenAI to analyze how it aligns to user's profile

		Parameters:
		- request object will contain key:value pairs -- aboutMeText, jobText, guid

		Returns:
		- A JSON response containing the analysis generated by the model.

		Note:
		- OpenAI prompts for System and User messages are hardcoded here. Will eventually move elsewhere to be more dynamic.
		- @TODO look into chaining responses, rather than adding display:none to the first part of the response.
	"""

	args = request.json
	# model = "gpt-3.5-turbo"
	model = "gpt-4"
	llm = ChatOpenAI(temperature=0, model=model)

	currentJob = args["jobText"]

	# Create Pydantic object that contains match_decision and match_summary
	class MatchAnalysis(BaseModel):
		matchSummary: str = Field(description="The summary explaining the match between user experience and job summary")
		matchDecision: str = Field(description="The strength of the match between user experience and job summary: Strong Match/Weak Match/Not a Match")

	matchParser = PydanticOutputParser(pydantic_object=MatchAnalysis)

	# STEP 1: Immediately reject jobs that exhibit any "red flags"

	## Probably break this out into the user settings UI at some point...
	redflags="""
		- The job description is short (less than 100 words)
		- The job description is vague, or not clear on specific requirements. For example: "I need a website" is too vague.
		- The job description is short or vague, but only promises to provide more details once someone is hired.
		- The job description is short or vague, and requires the candidate to sign an NDA/non-disclosure-agreement.
		- The job description acknowledges a low budget, but promises either profit sharing or promises that it may lead to "future work"
		- The job emphasizes urgency. For example if the deadline is "ASAP" then it is a red flag.
		- The job description is written in a tone of voice that is excessively rude, bossy, or excessively negative
	"""

	redflags_chat_template = ChatPromptTemplate.from_messages([
		SystemMessagePromptTemplate.from_template("""
				Your task is to take a job description and analyze it against a series of 'red flags', to determine if the job description violates any of the red flags.
				If the job description violates any of the red flags, return the following: (a description of the red flag it violated)
				Otherwise, return the following: False
				If you are not sure, return the following: False

				A list of 'red flags' are as follows:
				{redflags}
				""" ),
		HumanMessagePromptTemplate.from_template("JOB DESCRIPTION: {job_description}")
	])

	isRedFlag = False
	redflag_chain = redflags_chat_template | llm | StrOutputParser()
	redflag_response = redflag_chain.invoke({"redflags": redflags, "job_description": currentJob})
	isRedFlag = redflag_response

	# print("------------------")
	# print("Red Flag analysis")
	# print(isRedFlag)

	if ( "False" != isRedFlag ):
		redflag_analysis = {
			"match_decision": "Not a Match",
			"match_summary": f"Rejected for Red Flag: {isRedFlag}",
			"job_summary": currentJob
			},
		# print(redflag_analysis)
		return jsonify(redflag_analysis[0])

	# If no red flags, then:
	# STEP 2: Technical Analysis of Job Description

	techanalysis_chat_template = ChatPromptTemplate.from_messages([
		SystemMessagePromptTemplate.from_template("""
			You are a senior developer & solutions architect. You are highly skilled at taking a job description and summarizing it in terms of
			techinical requirements, and the skills that would be required to complete that task. Your summary should focus on explaining the
			skills, concepts, and experience that a job candidate would need to have in order to fulfill the requirements in the job description.
			You are allowed to make reasonable assumptions about things that may not be explicitly stated in the job description.

			Your summary should be between 1 and 3 paragraphs.


			"""),
			HumanMessagePromptTemplate.from_template("JOB DESCRIPTION: {job_description}")

			#### Maybe add following back to prompt:
			# If there are any major questions that would need to be answered in order for a developer to give a reasonable price quote, then
			# make a list of those questions following your summary. You should include questions only if it is absolutely necessary, and no more than 5 questions.
	])

	techanalysis_chain = techanalysis_chat_template | llm | StrOutputParser() # Don't use Pydantic parser since this is only part of the final output
	techanalysis_response = techanalysis_chain.invoke({"job_description": currentJob})
	techanalysis = techanalysis_response

	# print("------------------")
	# print("Tech analysis")
	# print(techanalysis)

	# STEP 3: Analyze strength of match based on user qualifications

	match_chat_template = ChatPromptTemplate.from_messages([
		SystemMessagePromptTemplate.from_template("""
			You are a senior developer & solutions architect with extensive experience leading a team of developers, and are highly skilled at evaluating
			whether or not a developer would be a good fit for a given job. You will be provided with a job description that includes technical requirements.
			You will also be provided with a description of a developer's experience, strengths, and interests.

			Your goal is to analyze whether or not the candidate is a good fit for the job description.
			You will provide a 1-paragraph summary of your analysis, referred to as the "match summary".
			You will then also provide a final "match decision" based on how strong of a match the candidate is for the job: "Strong Match", "Weak Match", or "Not a Match".

			The Job Description is provided below:
			{techanalysis}

			Format Instructions:
			{format_instructions}
			"""),
		HumanMessagePromptTemplate.from_template("Candidate Profile: {candidate_profile}")
	])

	format_instructions = matchParser.get_format_instructions()

	match_chain = match_chat_template | llm | matchParser

	match_response = match_chain.invoke({
		"techanalysis": techanalysis,
		"candidate_profile": args["aboutMeText"],
		"format_instructions": format_instructions
		})

	analysis = {
		"match_decision": match_response.matchDecision,
		"match_summary": match_response.matchSummary,
		"job_summary": currentJob
	},

	print(analysis)
	return jsonify(analysis[0])


	# try:
	# 	return jsonify(content.dict())

	# except Exception as error:
	# 	print('Error generating analysis:', error)
	# 	return "Error generating output."


@app.route("/fetch-upwork-jobs-rss")
def fetch_upwork_jobs_rss():
	"""
		Fetches list of jobs from Upwork RSS feed - specific to an individual account's saved search options. DOES NOT scrape the Upwork website.

		Returns:
			list: A list of job information dictionaries.

		Raises:
			Exception: If there is an error fetching the Upwork RSS feed.

		Notes:
		- @TODO URL currently hardcoded. Move it elsewhere to make the config parameters in the URL more dynamic & changeable
		- @TODO parse more data points from the Upwork RSS feed
	"""

	## Upwork RSS Feed URL
	# This URL should populate to your saved search options (keyword, budget, etc)
	# target_url = 'https://www.upwork.com/ab/feed/jobs/rss?api_params=1&contractor_tier=1,2,3&hourly_rate=50-&job_type=hourly,fixed&orgUid=872559107033931777&paging=0;3&q=wordpress&securityToken=de56b8790f403c07196293547743d7d0aa964c95b1ad8dbba549fb823dfdbf2ef9ca3f6cb441593ab02952d74ecd8bc19ccf63dd5173aea09e263182b98f2c55&sort=recency&userUid=742862918896668672&user_location_match=1'
	# target_url = 'https://www.upwork.com/ab/feed/jobs/rss?q=wordpress&sort=recency&user_location_match=1&paging=0%3B10&api_params=1&userUid=742862918896668672'
	target_url = 'https://www.upwork.com/ab/feed/jobs/rss?q=wordpress&sort=recency&user_location_match=1&paging=0;2&api_params=1&hourly_rate=50-&job_type=hourly,fixed'

	jobs = []

	try:
		response = requests.get(target_url)

		# RSS Data returned in XML format. Need to parse
		data = ET.fromstring(response.text)
		items = data.findall('.//item')

		'''
			Example structure:
			<item>
				<title>
				<link>
				<description> // Contains <b>Skills</b>, <b>Budget</b>, <b>Hourly Range</b> which we can further parse out
				<content:encoded> //same as description
				<pubDate>
				<guid>
			</item>
		'''

		for job in items:

			titleItem = job.find('title')

        	# Remove excessive upwork branding from title
			if titleItem is not None and titleItem.text.endswith(" - Upwork"):
				title = titleItem.text.rsplit(" - Upwork", 1)[0]
			else:
				title = titleItem.text

			description = job.find('description').text

			# Budget is nested within description as text content. Need regex pattern match.
			# Upwork jobs can either be fixed-price or hourly-range:
			# 	If fixed-price, value labeled as "Budget" within description content.
			# 	If hourly-range, value labeled as "Hourly Range" within description content.
			# Use regex to check one, then the other
			budgetMatchFixed = re.search(r'(<b>Budget</b>: \$(\d+))', description)
			budgetMatchHourly = re.search(r'(<b>Hourly Range</b>: (\$\d+\.\d+-\$\d+\.\d+))', description)

			budget = "N/A"

			if budgetMatchFixed:
				budget = "$" +budgetMatchFixed.group(2)
				description = re.sub(re.escape(budgetMatchFixed.group(1)), '', description) # Remove from description content to avoid redundancy
			elif budgetMatchHourly:
				budget = budgetMatchHourly.group(2)
				description = re.sub(re.escape(budgetMatchHourly.group(1)), '', description) # Remove from description content to avoid redundancy

			# Remove "Posted On" line from description content to prevent redundancy, since we extract it elsewhere
			postedOnMatch = re.search(r'(<b>Posted On</b>: .+? UTC<br />)', description)
			if postedOnMatch:
				description = re.sub(re.escape(postedOnMatch.group(1)), '', description)

			job_info = {
				'guid': job.find('guid').text,
				'aiAnalysis': {
					'decision': '',
					'summary': ''
				},
				'budget': budget,
				'description': description,
				'feedback': {},
				'title': title,
				'url': job.find('link').text,
				'pubDate': job.find('pubDate').text
			}
			# print(job_info)
			jobs.append(job_info)

	except Exception as error:
		print('Error fetching upwork RSS:', error)

	return jsonify(jobs)


@app.route("/generate-proposal", methods=["POST"])
def generate_proposal():
	"""
		Similar to generate_analysis(), however generate a proposal/cover letter tailored to the job & user, rather than analyzing the match quality

		Parameters:
		- request object will contain key:value pairs -- aboutMeText, jobText

		Returns:
		- A JSON response containing the proposal generated by the model.

		Note:
		- OpenAI prompts for System and User messages are hardcoded here. Will eventually move elsewhere to be more dynamic.
	"""

	args = request.json
	model = "gpt-3.5-turbo"
	llm = ChatOpenAI(temperature=0, model=model)

	user_prompt = f'''
		MY EXPERIENCE: ### {args["aboutMeText"]} ###
		JOB DESCRIPTION: ### {args["jobText"]} ###
	'''

	template = ChatPromptTemplate.from_messages([
		(
			"system",
			'''
				CONTEXT: You're an expert at writing cover letters, geared towards applicants who are applying for web-development
				freelance jobs on Upwork. Your goal is to take inputs provided by the user, and output a well-written cover letter.

				The user will provide you with two inputs: MY_EXPERIENCE, and JOB_DESCRIPTION.

				Based on these two inputs, you should construct a well-written cover letter that will help the user apply for the job and stand out from the competition.
				This cover letter should be specifically tailored to the JOB_DESCRIPTION and MY_EXPERIENCE, and should only make reference to things that are explicitly mentioned within MY_EXPERIENCE and JOB_DESCRIPTION.

				The output cover letter should be between 2 and 4 paragraphs.
				It should be written in a friendly and conversational manner, rather than a formal or robotic tone.
				The first paragraph should start with a brief introduction.
				The middle paragraphs should emphasize the overlap between MY_EXPERIENCE and the JOB_DESCRIPTION.
				Only address aspects of JOB_DESCRIPTION that are a match with MY_EXPERIENCE.
				The closing paragraph should invite the hiring manager to view the user's upwork profile, and ask the hiring manager if they'd like to setup a call to "chat more" sometime.
			'''
		),
		(
			"human", user_prompt
		)
	])

	try:
		answer = llm(template.format_messages(user_prompt=user_prompt))
		analysis = answer.content
		return jsonify(analysis)
	except Exception as error:
		print('Error generating analysis:', error)
		return "Error generating output."


if __name__ == '__main__':
	app.run()
